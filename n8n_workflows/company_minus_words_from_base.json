{
  "createdAt": "2025-09-15T16:12:00.035Z",
  "updatedAt": "2025-10-14T08:19:56.431Z",
  "id": "o5L3i8eq9JK9oLwL",
  "name": "company_minus_words_from_base",
  "active": false,
  "isArchived": false,
  "nodes": [
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        -480,
        -96
      ],
      "id": "a7cee990-ca1e-4f06-9a8c-7eee5568a802",
      "name": "Loop Over Items"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "8a679d23-f5a1-4bda-955e-f03cb1fd40fc",
              "name": "company_id",
              "value": "={{ $('When Executed by Another Workflow').item.json.company_id }}",
              "type": "number"
            }
          ]
        },
        "includeOtherFields": true,
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -704,
        -96
      ],
      "id": "08c83230-67a3-489c-aebc-eee593e5068c",
      "name": "set company_id"
    },
    {
      "parameters": {
        "content": "тех долг - автоматическая обработка и удаление своих регионов"
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -512,
        -640
      ],
      "id": "5cd1b29c-7c8e-491d-9202-7121e81a5c02",
      "name": "Sticky Note"
    },
    {
      "parameters": {
        "inputSource": "passthrough"
      },
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [
        -1456,
        -96
      ],
      "id": "a78fa162-a3ef-463f-b3db-7a7beed4adf0",
      "name": "When Executed by Another Workflow"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO business_processes_states (business_process_id, company_id,n8n_workflow_execution_id,n8n_workflow_root_execution_id, started)\nSELECT MAX(business_process_id), $2,$3,$4, NOW()\nFROM public.business_processes\nWHERE n8n_process_name = $1;",
        "options": {
          "queryReplacement": "=[{{$workflow.name}},{{$json.company_id}},{{$execution.id}},{{ $('When Executed by Another Workflow').item.json.root_execution_id }}]"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        -1248,
        -96
      ],
      "id": "813d4425-b0f9-47e2-8178-dd8e7e8076b0",
      "name": "Mark_workwlow_started",
      "credentials": {
        "postgres": {
          "id": "4YkdFJcdTgzo9hkz",
          "name": "PGvector"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "update business_processes_states set finished=NOW(),tokens_used=0,steps_passed=1,steps_total=1 where business_process_id=(select MAX(business_process_id) from business_processes where n8n_process_name=$1) and n8n_workflow_execution_id=$2",
        "options": {
          "queryReplacement": "=[{{$workflow.name}},{{$execution.id}}]"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        512,
        -560
      ],
      "id": "ba3ac614-4ba3-4017-830e-ff6b9481665c",
      "name": "Mark_workflow_completed",
      "executeOnce": true,
      "credentials": {
        "postgres": {
          "id": "4YkdFJcdTgzo9hkz",
          "name": "PGvector"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Function-Node (Run Once)\nconst workflowData = $getWorkflowStaticData('global');\nworkflowData.steps_passed = 0;\nworkflowData.tokens_used = 0;\nworkflowData.step = 0;\nreturn $input.all();\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1088,
        -96
      ],
      "id": "3788d6d1-dc9f-4346-80fc-0c89a0e7024a",
      "name": "Init total counter"
    },
    {
      "parameters": {
        "operation": "select",
        "schema": {
          "__rl": true,
          "mode": "list",
          "value": "public"
        },
        "table": {
          "__rl": true,
          "value": "minus_words_base",
          "mode": "list",
          "cachedResultName": "minus_words_base"
        },
        "returnAll": true,
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        -896,
        -96
      ],
      "id": "b0f27d76-135e-46c9-a195-247f906505d1",
      "name": "Get base minus_words",
      "credentials": {
        "postgres": {
          "id": "4YkdFJcdTgzo9hkz",
          "name": "PGvector"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO minus_words (minus_word_embedding, company_id, minus_word)\nVALUES ($1::vector, $2, $3);",
        "options": {
          "queryReplacement": "=[\n  { \"value\": \"={{'[' + JSON.parse($json.minus_word_embedding).map(e => Number(e)).join(',') + ']'}}\" },\n  { \"value\": \"={{$json.company_id}}\" },\n  { \"value\": \"={{$json.minus_word}}\" }\n]"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        -16,
        -80
      ],
      "id": "eec0d635-e445-4ba3-8b46-8a637fa8e478",
      "name": "insert minus_word",
      "credentials": {
        "postgres": {
          "id": "4YkdFJcdTgzo9hkz",
          "name": "PGvector"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO public.minus_words_origin(\n\tminus_word_id, key_word_id, origin_weight)\n\tVALUES ($1, 0, 1);",
        "options": {
          "queryReplacement": "={{ $json.id }}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        176,
        -80
      ],
      "id": "ebd19e48-c031-4b0e-ac06-cb6463090c19",
      "name": "insert minus_words_origin",
      "credentials": {
        "postgres": {
          "id": "Hx2VFmUi5WO2K4QX",
          "name": "Postgres account 2"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT yandex_region\n\tFROM companies where company_id=$1;",
        "options": {
          "queryReplacement": "={{ $('When Executed by Another Workflow').item.json.company_id }}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        64,
        -288
      ],
      "id": "993c1bf8-f618-4685-939e-862a51858235",
      "name": "get region",
      "executeOnce": true,
      "credentials": {
        "postgres": {
          "id": "hNuVeLeeeSX0vLBj",
          "name": "n8n service"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// === Code: normalize_and_ngrams ===\n// INPUT:  HTTP Webhook body { phrase: string, threshold?: number }\n// OUTPUT: { threshold: number, candidates: string[], tokens: string[] }\n// PURPOSE:\n//   1) Normalize the phrase (lowercase, keep letters/digits/underscore and - + #)\n//   2) Remove Russian prepositions as separate words (not touching - + #)\n//   3) Tokenize and build 1..3-gram unique candidates preserving order\n//   4) Provide threshold (default 0.88) downstream\n\n// Input JSON: { company_name, text, threshold? }\nconst body = $json;\nconst prepositions = [\n  \"в\",\"без\",\"до\",\"из\",\"к\",\"и\",\"на\",\"по\",\"о\",\"от\",\"перед\",\"при\",\n  \"через\",\"с\",\"у\",\"за\",\"над\",\"об\",\"под\",\"про\",\"для\",\"между\"\n];\n\n// Нормализуем регистр\nlet text = String(body.args.phrase ?? \"\").toLowerCase();\n\n// Экранируем спецсимволы\nconst escape = s => s.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\nconst alts = prepositions.map(escape).join(\"|\");\n\n// Разрешаем буквы, цифры, подчёркивание, а также - + #\nconst re = new RegExp(\n  `(^|[^\\\\p{L}\\\\p{N}_\\\\-+#])(?:${alts})(?=$|[^\\\\p{L}\\\\p{N}_\\\\-+#])`,\n  \"giu\"\n);\n\n// Удаляем предлоги, сохраняя левый разделитель\ntext = text.replace(re, \"$1\");\n\n// Чистим пробелы\ntext = text.replace(/\\s+/g, \" \").trim();\n//const company = body.company_name;\nconst threshold = Math.min(Math.max(\n  Number(String(body?.args?.threshold ?? 0.88).replace(',', '.').trim()) || 0.88\n, 0), 1);\n\nconst tokens = (text.match(/[A-Za-zА-Яа-яЁё0-9][A-Za-zА-Яа-яЁё0-9&.\\-]{0,}/g) || [])\n  .map(s => s.trim())\n  .filter(Boolean);\n\nconst MAX_N = 3;\nconst set = new Set();\nfor (let i = 0; i < tokens.length; i++) {\n  for (let n = 1; n <= MAX_N && i + n <= tokens.length; n++) {\n    const phrase = tokens.slice(i, i+n).join(' ');\n    set.add(phrase);\n  }\n}\nlet candidates = Array.from(set);\n// если пусто — добавляем пустую строку\nif (candidates.length === 0) {\n  candidates = [\"\"];\n}\n\nreturn [{ json: { threshold, candidates,MAX_N } }];\n"
      },
      "id": "b20d5915-2f1c-4bf8-8269-0c638aae3658",
      "name": "Code: normalize_and_ngrams",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        560,
        -272
      ],
      "notes": "Normalize phrase, strip Russian prepositions (keeping - + #), tokenize, and produce 1..3-grams."
    },
    {
      "parameters": {
        "jsCode": "// === Code: explode_candidates ===\n// INPUT:  { threshold, candidates[] }\n// OUTPUT: array of items: { candidate, threshold }\n// PURPOSE: fan-out each n-gram into its own item for embedding + DB lookup\n\nconst { threshold, candidates } = $json;\n\nreturn candidates.map(c => ({ json: { candidate: c, threshold } }));"
      },
      "id": "072e18a3-c6fe-4fb1-ae66-8d6aa310c9d1",
      "name": "Code: explode_candidates",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        752,
        -240
      ],
      "notes": "Explode the array of n-gram candidates into one item per candidate."
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.openai.com/v1/embeddings",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "openAiApi",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"model\": \"text-embedding-3-small\",\n  \"input\": \"{{$json.candidate}}\"\n}",
        "options": {
          "redirect": {
            "redirect": {}
          },
          "timeout": 30000
        }
      },
      "id": "7e586be3-01cb-4fb1-985c-39da9d584273",
      "name": "HTTP: OpenAI Embeddings",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        992,
        -240
      ],
      "retryOnFail": true,
      "waitBetweenTries": 5000,
      "credentials": {
        "openAiApi": {
          "id": "V8R8KiZKXscJQ1sL",
          "name": "OpenAi account"
        }
      },
      "notes": "Creates an embedding for each candidate n-gram.\n- Set your OpenAI credential on this node.\n- Batch mode is possible later; this keeps it simple and explicit."
    },
    {
      "parameters": {
        "jsCode": "// === Code: build_vector_literal ===\n// INPUT:  HTTP response(s) from OpenAI embeddings (one per candidate)\n// OUTPUT: items: { vector: \"[float,...]\", idx, candidate, threshold }\n// PURPOSE: Convert embedding array into a Postgres vector literal string and\n//          carry candidate + threshold forward for alignment\n\nconst sourceAll = $('Code: explode_candidates').all();\n\nconst out = $input.all().map((r, i) => {\n  // OpenAI HTTP node may put data in r.json.body.data or r.json.data depending on version\n  const emb = r.json?.body?.data?.[0]?.embedding ?? r.json?.data?.[0]?.embedding;\n  if (!Array.isArray(emb) || emb.length === 0) {\n    throw new Error('Embedding not found for item #' + i);\n  }\n  const vector = '[' + emb.map(Number).join(',') + ']';\n  const candidate = sourceAll[i]?.json?.candidate;\n  const threshold = sourceAll[i]?.json?.threshold;\n  return { json: { vector, idx: i, candidate, threshold,company_id:$('When Executed by Another Workflow').first().json.args.company_id } };\n});\n\nreturn out;"
      },
      "id": "e265dcd1-3de9-4c98-b51d-0fa5801ec68b",
      "name": "Code: build_vector_literal",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1248,
        -240
      ],
      "notes": "Convert embedding arrays into a pgvector literal (e.g., \"[0.1,0.2,...]\")."
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT v.phrase,  0 - (v.phrase_embedding <#> $1::vector) AS similarity FROM company_content v where company_id=$2\n  ORDER BY v.phrase_embedding <#> $1::vector LIMIT 1;",
        "options": {
          "queryReplacement": "={{$json.vector}},{{$json.company_id}}"
        }
      },
      "id": "579e8eb5-e7df-401c-8b27-55c65df770d3",
      "name": "Postgres: vector search",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [
        1520,
        -240
      ],
      "credentials": {
        "postgres": {
          "id": "4YkdFJcdTgzo9hkz",
          "name": "PGvector"
        }
      },
      "notes": "Looks up the nearest content phrase using pgvector (<#> = cosine distance if normalized). \n- Assumes table company_content(phrase text, phrase_embedding vector).\n- Returns top-1 match with similarity = -distance."
    },
    {
      "parameters": {
        "jsCode": "// === Code: threshold_flag ===\n// INPUT:  Postgres results (top-1 row per candidate)\n// OUTPUT: items: { candidate, matched, similarity, pass }\n// PURPOSE: Compare best similarity to threshold and flag whether it passes\n\nconst ctx = $('Code: normalize_and_ngrams').first().json; // { threshold, candidates, tokens }\nconst exploded = $('Code: explode_candidates').all();\n\nconst out = $input.all().map((row, i) => {\n  const best = row.json || {};\n  const candidate = exploded[i]?.json?.candidate;\n  const similarity = typeof best.similarity === 'number' ? best.similarity : -1;\n  const pass = similarity >= (ctx.threshold ?? 0.88);\n  return { json: { candidate, matched: best.phrase, similarity, pass } };\n});\n\nreturn out;"
      },
      "id": "aa9471c9-d897-445f-b163-77c0dfb43a43",
      "name": "Code: threshold_flag",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1776,
        -240
      ],
      "notes": "Compares nearest match similarity with the threshold and marks pass/fail."
    },
    {
      "parameters": {
        "jsCode": "// === Code: collect_non_matches ===\n// INPUT:  { candidate, matched, similarity, pass }\n// OUTPUT: single item: { non_matches: string[], meta: {...} }\n// PURPOSE: Keep only candidates that did NOT pass threshold (i.e., non-matches)\n\nconst ctx = $('Code: normalize_and_ngrams').first().json; // for threshold & counts\n\nconst failed = $input.all()\n  .map(i => i.json)\n  .filter(j => !j.pass);\n\nreturn [{\n  json: {\n    non_matches: failed.map(x => x.candidate),\n    meta: {\n      threshold: ctx.threshold,\n      candidates_total: ctx.candidates.length,\n      checked_ngrams: '1..'+ctx.MAX_N\n    }\n  }\n}];"
      },
      "id": "1ac4bdc9-5d03-41ea-bee8-3409dcef2f7a",
      "name": "Code: collect_non_matches",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2032,
        -240
      ],
      "notes": "Produces the final response for the Webhook: list of n-grams that have no strong match."
    },
    {
      "parameters": {
        "jsCode": "// Настройте имена полей под себя:\nconst INPUT_FIELD  = 'yandex_region'; // где лежит исходная строка\nconst OUTPUT_FIELD = 'regions';     // куда записать массив\n\nfunction parseCsvLine(line) {\n  const out = [];\n  let cur = '';\n  let inQuotes = false;\n\n  for (let i = 0; i < line.length; i++) {\n    const ch = line[i];\n    if (ch === '\"') {\n      // двойные кавычки внутри кавычек -> одна кавычка\n      if (inQuotes && line[i + 1] === '\"') { cur += '\"'; i++; }\n      else { inQuotes = !inQuotes; }\n    } else if (ch === ',' && !inQuotes) {\n      out.push(cur);\n      cur = '';\n    } else {\n      cur += ch;\n    }\n  }\n  out.push(cur);\n\n  // trim + убрать пустые\n  return out.map(s => s.trim()).filter(s => s.length > 0);\n}\n\nconst out = $input.all().map(item => {\n  const raw = String(item.json?.[INPUT_FIELD] ?? '').trim();\n  const arr = raw ? parseCsvLine(raw) : [];\n  return { json: { ...item.json, [OUTPUT_FIELD]: arr } };\n});\n\nreturn out;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        272,
        -288
      ],
      "id": "b5a47a15-f900-43be-a47a-72b3f057e547",
      "name": "get array of regions"
    },
    {
      "parameters": {
        "content": "тех долг - через Яндекс API дополнить всеми дочерними регионами. Возможно отдельная ветка если вся россия то просто удалить все гео минус слова",
        "height": 256,
        "width": 304
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        192,
        -400
      ],
      "id": "02898096-6425-4124-9550-04f93afda46e",
      "name": "Sticky Note1"
    }
  ],
  "connections": {
    "Loop Over Items": {
      "main": [
        [
          {
            "node": "get region",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "insert minus_word",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "set company_id": {
      "main": [
        [
          {
            "node": "Loop Over Items",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "When Executed by Another Workflow": {
      "main": [
        [
          {
            "node": "Mark_workwlow_started",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mark_workwlow_started": {
      "main": [
        [
          {
            "node": "Init total counter",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Init total counter": {
      "main": [
        [
          {
            "node": "Get base minus_words",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get base minus_words": {
      "main": [
        [
          {
            "node": "set company_id",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "insert minus_word": {
      "main": [
        [
          {
            "node": "insert minus_words_origin",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "insert minus_words_origin": {
      "main": [
        [
          {
            "node": "Loop Over Items",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "get region": {
      "main": [
        [
          {
            "node": "get array of regions",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code: normalize_and_ngrams": {
      "main": [
        [
          {
            "node": "Code: explode_candidates",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code: explode_candidates": {
      "main": [
        [
          {
            "node": "HTTP: OpenAI Embeddings",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP: OpenAI Embeddings": {
      "main": [
        [
          {
            "node": "Code: build_vector_literal",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code: build_vector_literal": {
      "main": [
        [
          {
            "node": "Postgres: vector search",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Postgres: vector search": {
      "main": [
        [
          {
            "node": "Code: threshold_flag",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code: threshold_flag": {
      "main": [
        [
          {
            "node": "Code: collect_non_matches",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "pinData": {
    "When Executed by Another Workflow": [
      {
        "json": {
          "company_id": 1,
          "root_execution_id": 74293
        }
      }
    ]
  },
  "versionId": "b60e762e-ec94-4402-903b-ae0c1cb1672c",
  "triggerCount": 0,
  "shared": [
    {
      "createdAt": "2025-09-15T16:12:00.035Z",
      "updatedAt": "2025-09-15T16:12:00.035Z",
      "role": "workflow:owner",
      "workflowId": "o5L3i8eq9JK9oLwL",
      "projectId": "spKmbJLU4mvACXIB"
    }
  ],
  "tags": []
}