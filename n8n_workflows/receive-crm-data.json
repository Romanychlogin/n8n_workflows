{
  "createdAt": "2025-10-07T21:30:12.820Z",
  "updatedAt": "2025-10-07T21:46:04.145Z",
  "id": "d4D0Fp4pO6Ch7S7C",
  "name": "Receive CRM data",
  "active": true,
  "isArchived": false,
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "c11cd095-1060-4c9c-87df-2a3c9d34deab",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        0,
        0
      ],
      "id": "6b11411b-3ee6-4590-977a-3dbbd005d09a",
      "name": "Webhook",
      "webhookId": "c11cd095-1060-4c9c-87df-2a3c9d34deab"
    },
    {
      "parameters": {
        "jsCode": "// 1) распарсим вход CRM\nconst crm = typeof $json.body === 'string' ? JSON.parse($json.body) : $json;\n\n// 2) параметры сопоставления\nconst now = Date.now();\nconst WINDOW_MS = 10 * 60 * 1000;     // окно ±10 минут (подстраивай)\nconst preferExactYclid = true;         // если есть yclid у CRM — жёстко по нему\n\n// 3) заберём последние N pending из Data Store (лимитируем для производительности)\nconst N = 200;\n\n// нода Data Store не тут — мы возьмём данные через helper\n// В n8n проще: добавь ДО этой Function ноду Data Store (Get Many, table site_leads, Return All: true, Limit: 200, Filter: { \"status\": \"pending\" })\n// и здесь просто читай $items(\"<Data Store Node Name>\", 0, 0).json\n// Ниже — логика выбора кандидата.\n\nconst pendingItems = $items('Data Store', 0, 0).map(i => i.json) || [];\n\n// 4) отфильтруем по окну времени\nconst inWindow = pendingItems.filter(r => Math.abs((r.ts_site || 0) - now) <= WINDOW_MS);\n\n// 5) если в CRM тоже есть yclid — матчим в первую очередь по нему\nlet best = null;\nif (preferExactYclid && crm.yclid) {\n  best = inWindow.find(r => (r.yclid || '') === crm.yclid);\n}\n\n// 6) иначе — по etext (если есть у одной из сторон)\nif (!best && crm.etext) {\n  best = inWindow.find(r => (r.etext || '') === crm.etext);\n}\n\n// 7) иначе — берём ближайшее по времени (минимальная дельта)\nif (!best) {\n  best = inWindow.sort((a,b) => Math.abs(a.ts_site - now) - Math.abs(b.ts_site - now))[0];\n}\n\n// 8) вернём два варианта исходов\nif (best) {\n  return [{\n    json: {\n      matched: true,\n      id: best.id,                 // id записи в Data Store (приходит из ноды Data Store → item.json.id)\n      ts_site: best.ts_site,\n      delta_ms: Math.abs(best.ts_site - now),\n      site: best,\n      crm: crm\n    }\n  }];\n} else {\n  return [{\n    json: {\n      matched: false,\n      reason: 'no_candidate_in_window',\n      window_ms: WINDOW_MS,\n      pending_count: pendingItems.length,\n      crm: crm\n    }\n  }];\n}"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        208,
        0
      ],
      "id": "0280247b-21b3-403b-8366-050088c9a937",
      "name": "Code in JavaScript"
    }
  ],
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "Code in JavaScript",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "meta": null,
  "pinData": {},
  "versionId": "5ecf1d37-1b45-4411-abc4-55d29c3969e2",
  "triggerCount": 1,
  "shared": [
    {
      "createdAt": "2025-10-07T21:30:12.820Z",
      "updatedAt": "2025-10-07T21:30:12.820Z",
      "role": "workflow:owner",
      "workflowId": "d4D0Fp4pO6Ch7S7C",
      "projectId": "spKmbJLU4mvACXIB"
    }
  ],
  "tags": []
}